//! Configuration management for Releasaurus.
//!
//! This module handles loading and parsing the Releasaurus configuration file (`releasaurus.toml`),
//! which allows users to customize changelog generation and specify multiple packages within
//! a repository for independent release management.
//!
//! # Configuration File
//!
//! The configuration file uses TOML format and supports the following sections:
//!
//! - `[changelog]`: Customization of changelog generation templates
//! - `[[package]]`: Definition of packages within the repository
//!
//! # Example Configuration
//!
//! ```toml
//! [changelog]
//! header = "# Custom Changelog Header"
//! footer = "Built by Releasaurus ðŸ¦•"
//!
//! [[package]]
//! path = "."
//! tag_prefix = "v"
//!
//! [[package]]
//! path = "./packages/web"
//! tag_prefix = "web-v"
//! ```
//!
//! # Default Behavior
//!
//! If no configuration file is found, sensible defaults are used that work for
//! most single-package repositories with standard changelog formatting.

use log::*;
use serde::Deserialize;
use std::{fs, path::Path};

use crate::{analyzer::config::DEFAULT_BODY, result::Result};

/// Default configuration filename that Releasaurus looks for in the project root.
///
/// This file should be placed at the root of the repository and contains TOML-formatted
/// configuration options for customizing changelog generation and package definitions.
const DEFAULT_CONFIG_FILE: &str = "releasaurus.toml";

/// Changelog generation configuration options.
///
/// This structure allows customization of the changelog output format using
/// [Tera](https://github.com/Keats/tera) templating engine. Templates have access
/// to release data including version information, commit groupings, and metadata.
///
/// # Template Variables
///
/// Templates receive the following variables:
/// - `version`: The release version string
/// - `date`: Release date in ISO 8601 format
/// - `commits`: Array of commit objects grouped by type
/// - `repository`: Repository metadata (URL, owner, etc.)
///
/// # Examples
///
/// ```toml
/// [changelog]
/// header = "# {{ repository.name }} Changelog"
/// body = """
/// ## [{{ version }}] - {{ date }}
/// {% for group, commits in commits | group_by(attribute="group") %}
/// ### {{ group | title }}
/// {% for commit in commits %}
/// - {{ commit.message }} ([{{ commit.id | truncate(length=7, end="") }}]({{ commit.link }}))
/// {% endfor %}
/// {% endfor %}
/// """
/// footer = "Generated by Releasaurus ðŸ¦•"
/// ```
#[derive(Debug, Clone, Deserialize)]
pub struct CliChangelogConfig {
    /// Main changelog body template using Tera template syntax.
    ///
    /// This template defines how the changelog content is formatted for each release.
    /// The default template groups commits by type (feat, fix, etc.) and provides
    /// a clean, readable format with links to commits.
    ///
    /// The template has access to all release data and can be customized to match
    /// your project's changelog style preferences.
    ///
    /// **Default**: Uses [`DEFAULT_BODY`] from the analyzer configuration.
    pub body: String,
    /// Optional header template prepended to the changelog.
    ///
    /// When specified, this template is rendered and placed at the top of the
    /// generated changelog. Useful for adding title formatting, repository
    /// information, or custom branding.
    ///
    /// **Default**: None (no header added).
    pub header: Option<String>,
    /// Optional footer template appended to the changelog.
    ///
    /// When specified, this template is rendered and placed at the bottom of the
    /// generated changelog. Commonly used for attribution, links to documentation,
    /// or additional metadata.
    ///
    /// **Default**: None (no footer added).
    pub footer: Option<String>,
}

impl Default for CliChangelogConfig {
    fn default() -> Self {
        Self {
            body: DEFAULT_BODY.to_string(),
            header: None,
            footer: None,
        }
    }
}

/// Configuration for individual packages within a repository.
///
/// This structure defines packages that should be managed independently within
/// a single repository. Each package can have its own versioning scheme, changelog,
/// and release cycle. This is particularly useful for monorepos or repositories
/// containing multiple related but independently versioned components.
///
/// # Use Cases
///
/// - **Monorepos**: Multiple applications or libraries in subdirectories
/// - **Multi-component projects**: Frontend and backend with different versions
/// - **Plugin architectures**: Core system with independently versioned plugins
/// - **Language bindings**: Multiple language bindings for the same API
///
/// # Examples
///
/// ```toml
/// # Root package (default)
/// [[package]]
/// path = "."
///
/// # Web application package
/// [[package]]
/// path = "./apps/web"
/// tag_prefix = "web-v"
///
/// # API package
/// [[package]]
/// path = "./apps/api"
/// tag_prefix = "api-v"
/// ```
#[derive(Debug, Clone, Deserialize)]
pub struct CliPackageConfig {
    /// Filesystem path to the package directory.
    ///
    /// This should be a valid directory path relative to the repository root.
    /// The path is used to:
    /// - Detect version files specific to this package
    /// - Scope commit analysis to changes affecting this package
    /// - Determine the appropriate version update strategy
    ///
    /// **Examples**:
    /// - `"."` for the repository root (default)
    /// - `"./packages/core"` for a package in a subdirectory
    /// - `"../sibling-repo"` for packages outside the main repo (if supported)
    pub path: String,
    /// Optional prefix for Git tags created for this package.
    ///
    /// When specified, tags for this package will be prefixed with this value.
    /// This allows multiple packages in the same repository to have distinct
    /// version tags without conflicts.
    ///
    /// **Examples**:
    /// - `None` - Creates tags like `1.0.0` (default)
    /// - `Some("v")` - Creates tags like `v1.0.0`
    /// - `Some("api-")` - Creates tags like `api-1.0.0`
    /// - `Some("web-v")` - Creates tags like `web-v1.0.0`
    ///
    /// **Default**: None (no prefix).
    pub tag_prefix: Option<String>,
}

impl Default for CliPackageConfig {
    fn default() -> Self {
        Self {
            path: ".".to_string(),
            tag_prefix: None,
        }
    }
}

/// Root configuration structure containing all Releasaurus settings.
///
/// This is the top-level configuration object that combines changelog settings
/// and package definitions. It represents the complete parsed content of a
/// `releasaurus.toml` file.
///
/// The structure uses `#[serde(default)]` to ensure that missing configuration
/// sections fall back to sensible defaults, making the configuration file
/// entirely optional for simple use cases.
///
/// # Configuration Sections
///
/// - **changelog**: Controls how changelogs are generated and formatted
/// - **packages**: Defines one or more packages to manage within the repository
///
/// # Default Behavior
///
/// If no configuration file is present, the default configuration:
/// - Uses standard changelog formatting suitable for most projects
/// - Treats the entire repository as a single package at the root (`.`)
/// - Creates tags without prefixes (`1.0.0`, `2.1.0`, etc.)
#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct CliConfig {
    /// Changelog generation configuration.
    ///
    /// Contains settings for customizing the format and content of generated
    /// changelogs, including header, body, and footer templates.
    pub changelog: CliChangelogConfig,
    /// List of packages to manage within this repository.
    ///
    /// Each package can have independent versioning and release cycles.
    /// At minimum, one package is required (defaulting to the repository root).
    ///
    /// The `#[serde(rename = "package")]` attribute allows the TOML configuration
    /// to use `[[package]]` sections instead of `[[packages]]`, following
    /// common TOML conventions for arrays of tables.
    #[serde(rename = "package")]
    pub packages: Vec<CliPackageConfig>,
}

impl Default for CliConfig {
    fn default() -> Self {
        Self {
            changelog: CliChangelogConfig::default(),
            packages: vec![CliPackageConfig::default()],
        }
    }
}

/// Load and parse the Releasaurus configuration file.
///
/// Attempts to locate and parse a `releasaurus.toml` configuration file in the
/// specified directory (or current directory if none provided). If no configuration
/// file is found, returns default configuration values.
///
/// # Arguments
///
/// * `dir` - Optional directory to search for the configuration file.
///   If `None`, searches in the current working directory.
///
/// # Returns
///
/// * `Result<CliConfig>` - Parsed configuration or default values
///
/// # Errors
///
/// Returns an error if:
/// - The configuration file exists but cannot be read
/// - The configuration file contains invalid TOML syntax
/// - Required configuration values are missing or invalid
///
/// # Examples
///
/// ```rust,ignore
/// use std::path::Path;
///
/// // Load from current directory
/// let config = load_config(None)?;
///
/// // Load from specific directory
/// let project_dir = Path::new("./my-project");
/// let config = load_config(Some(project_dir))?;
/// ```
///
/// # Configuration Discovery
///
/// The function searches for `releasaurus.toml` in the specified directory.
/// Future versions may implement upward directory traversal to find
/// configuration files in parent directories.
pub fn load_config(dir: Option<&Path>) -> Result<CliConfig> {
    let project = dir.unwrap_or(Path::new("."));
    let config_path = project.join(DEFAULT_CONFIG_FILE);
    let exists = std::fs::exists(config_path.clone())?;

    // search for config file walking up ancestors as necessary
    if exists {
        info!("found config file: {}", config_path.display());
        if let Ok(content) = fs::read_to_string(config_path) {
            let cli_config: CliConfig = toml::from_str(&content)?;
            return Ok(cli_config);
        }
    }

    // otherwise return default config
    info!(
        "no configuration file found for {DEFAULT_CONFIG_FILE}: using default config"
    );
    Ok(CliConfig::default())
}

/// Unit tests for configuration loading and parsing functionality.
#[cfg(test)]
mod tests {
    use tempfile::TempDir;

    use super::*;

    /// Test that default configuration values are properly initialized.
    #[test]
    fn loads_defaults() {
        let config = CliConfig::default();
        assert!(!config.changelog.body.is_empty())
    }

    /// Test loading configuration from a valid TOML file.
    #[test]
    fn loads_config_file() {
        let tmp = TempDir::new().unwrap();

        let content = r#"
[[package]]
path = "./some/path"
"#;

        fs::write(tmp.path().join(DEFAULT_CONFIG_FILE), content.as_bytes())
            .unwrap();

        let result = load_config(Some(tmp.path()));
        assert!(result.is_ok(), "failed to load config file");

        let config = result.unwrap();

        assert_eq!(config.packages.len(), 1, "packages length should be 1");
        assert_eq!(
            config.packages[0].path, "./some/path",
            "packages path should be ./some/path"
        );
    }

    /// Test fallback to default configuration when no file exists.
    #[test]
    fn loads_default_config() {
        let tmp = TempDir::new().unwrap();

        let result = load_config(Some(tmp.path()));
        assert!(result.is_ok(), "failed to load config file");

        let config = result.unwrap();
        assert_eq!(config.packages.len(), 1, "packages length should be 1");
        assert_eq!(
            config.packages[0].path, ".",
            "package path should be \".\""
        );
    }
}

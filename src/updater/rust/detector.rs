use std::path::Path;

use crate::updater::{
    detection::{
        helper::DetectionHelper,
        traits::FrameworkDetector,
        types::{DetectionPattern, FrameworkDetection},
    },
    framework::Framework,
};
use color_eyre::eyre::Result;

pub struct RustDetector {}

impl RustDetector {
    pub fn new() -> Self {
        Self {}
    }
}

impl FrameworkDetector for RustDetector {
    fn name(&self) -> &str {
        "rust"
    }

    fn detect(&self, path: &Path) -> Result<FrameworkDetection> {
        let pattern = DetectionPattern {
            manifest_files: vec!["Cargo.toml"],
            support_files: vec!["Cargo.lock", "src/main.rs", "src/lib.rs"],
            content_patterns: vec![
                "[package]",
                "[workspace]",
                "[dependencies]",
            ],
            base_confidence: 0.9,
        };

        DetectionHelper::analyze_with_pattern(
            path,
            pattern.clone(),
            |support_evidence| FrameworkDetection {
                framework: Framework::Rust,
                confidence: DetectionHelper::calculate_confidence(
                    &pattern,
                    &support_evidence,
                ),
                evidence: support_evidence,
            },
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_rust_detection() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Create Cargo.toml
        fs::write(
            path.join("Cargo.toml"),
            r#"[package]
name = "test-crate"
version = "1.0.0"

[dependencies]
serde = "1.0"
"#,
        )
        .unwrap();

        // Create supporting files
        fs::create_dir_all(path.join("src")).unwrap();
        fs::write(path.join("src/lib.rs"), "// test").unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));

        assert!(detection.confidence > 0.8);

        assert!(detection.evidence.contains(&"found Cargo.toml".to_string()));
    }

    #[test]
    fn test_workspace_detection() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Create workspace Cargo.toml
        fs::write(
            path.join("Cargo.toml"),
            r#"[workspace]
members = [
    "crates/core",
    "crates/cli"
]

[workspace.dependencies]
serde = "1.0"
"#,
        )
        .unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));

        assert!(
            detection
                .evidence
                .contains(&"contains [workspace]".to_string())
        );
    }

    #[test]
    fn test_no_rust_detection() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Create a non-Rust file
        fs::write(path.join("package.json"), r#"{"name": "test"}"#).unwrap();

        let detector = RustDetector::new();
        let result = detector.detect(path);

        // Should return an error since no Cargo.toml found
        assert!(result.is_err());
    }

    #[test]
    fn test_detection_with_main_rs() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Create Cargo.toml with minimal content
        fs::write(
            path.join("Cargo.toml"),
            r#"[package]
name = "test-bin"
version = "0.1.0"
"#,
        )
        .unwrap();

        // Create src/main.rs instead of lib.rs
        fs::create_dir_all(path.join("src")).unwrap();
        fs::write(path.join("src/main.rs"), "fn main() {}").unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));
        assert!(detection.confidence > 0.8);
        assert!(
            detection
                .evidence
                .contains(&"found src/main.rs".to_string())
        );
    }

    #[test]
    fn test_detection_with_cargo_lock() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        fs::write(
            path.join("Cargo.toml"),
            r#"[package]
name = "test-crate"
version = "1.0.0"
"#,
        )
        .unwrap();

        fs::write(
            path.join("Cargo.lock"),
            r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "test-crate"
version = "1.0.0"
"#,
        )
        .unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));
        assert!(detection.evidence.contains(&"found Cargo.lock".to_string()));
    }

    #[test]
    fn test_detection_with_dependencies_section() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        fs::write(
            path.join("Cargo.toml"),
            r#"[package]
name = "test-crate"
version = "1.0.0"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = "1.0"
"#,
        )
        .unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));
        assert!(
            detection
                .evidence
                .contains(&"contains [dependencies]".to_string())
        );
    }

    #[test]
    fn test_detection_high_confidence_with_all_evidence() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        // Create comprehensive Rust project structure
        fs::write(
            path.join("Cargo.toml"),
            r#"[package]
name = "comprehensive-crate"
version = "1.0.0"

[dependencies]
serde = "1.0"
tokio = "1.0"
"#,
        )
        .unwrap();

        fs::write(path.join("Cargo.lock"), "# Generated by Cargo").unwrap();

        fs::create_dir_all(path.join("src")).unwrap();
        fs::write(path.join("src/lib.rs"), "pub mod test;").unwrap();
        fs::write(path.join("src/main.rs"), "fn main() {}").unwrap();

        let detector = RustDetector::new();
        let detection = detector.detect(path).unwrap();

        assert!(matches!(detection.framework, Framework::Rust));

        // Should have very high confidence with all evidence present
        assert!(detection.confidence > 0.9);

        // Check that multiple pieces of evidence were found
        assert!(detection.evidence.contains(&"found Cargo.toml".to_string()));
        assert!(detection.evidence.contains(&"found Cargo.lock".to_string()));
        assert!(detection.evidence.contains(&"found src/lib.rs".to_string()));
        assert!(
            detection
                .evidence
                .contains(&"found src/main.rs".to_string())
        );
        assert!(
            detection
                .evidence
                .contains(&"contains [package]".to_string())
        );
        assert!(
            detection
                .evidence
                .contains(&"contains [dependencies]".to_string())
        );
    }

    #[test]
    fn test_detector_name() {
        let detector = RustDetector::new();
        assert_eq!(detector.name(), "rust");
    }

    #[test]
    fn test_empty_directory() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path();

        let detector = RustDetector::new();
        let result = detector.detect(path);

        // Should return an error for empty directory with no manifest files
        assert!(result.is_err());
    }
}

//! Cargo updater for handling rust projects
use log::*;
use std::path::Path;

use crate::updater::rust::cargo_lock::CargoLock;
use crate::updater::rust::cargo_toml::CargoToml;
use crate::{
    result::Result,
    updater::framework::{Framework, Package},
    updater::traits::PackageUpdater,
};

/// Rust package updater for Cargo projects.
pub struct RustUpdater {
    cargo_toml: CargoToml,
    cargo_lock: CargoLock,
}

impl RustUpdater {
    pub fn new() -> Self {
        Self {
            cargo_toml: CargoToml::new(),
            cargo_lock: CargoLock::new(),
        }
    }
}

impl PackageUpdater for RustUpdater {
    fn update(&self, root_path: &Path, packages: Vec<Package>) -> Result<()> {
        let rust_packages = packages
            .into_iter()
            .filter(|p| matches!(p.framework, Framework::Rust))
            .collect::<Vec<Package>>();

        info!(
            "Found {} rust packages in {}",
            rust_packages.len(),
            root_path.display(),
        );

        let packages_with_names =
            self.cargo_toml.get_packages_with_names(rust_packages);

        if self.cargo_toml.is_workspace(root_path)? {
            self.cargo_lock
                .process_workspace_lockfile(root_path, &packages_with_names)?;
        }

        self.cargo_toml.process_packages(&packages_with_names)?;
        self.cargo_lock.process_packages(&packages_with_names)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzer::release::Tag;
    use crate::updater::framework::{Framework, Package};
    use std::fs;
    use tempfile::TempDir;

    fn create_test_package(
        name: &str,
        path: &str,
        version: &str,
        framework: Framework,
    ) -> Package {
        Package::new(
            name.to_string(),
            path.to_string(),
            Tag {
                sha: "abc123".into(),
                name: format!("v{}", version),
                semver: semver::Version::parse(version).unwrap(),
            },
            framework,
        )
    }

    #[test]
    fn test_new() {
        let updater = RustUpdater::new();
        // Just verify we can create an instance
        assert_eq!(std::mem::size_of_val(&updater), 0);
    }

    #[test]
    fn test_update_single_rust_package() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let pkg_dir = root_path.join("test-crate");
        fs::create_dir_all(&pkg_dir).unwrap();

        // Create Cargo.toml
        fs::write(
            pkg_dir.join("Cargo.toml"),
            r#"[package]
name = "test-crate"
version = "1.0.0"

[dependencies]
serde = "1.0"
"#,
        )
        .unwrap();

        // Create Cargo.lock
        fs::write(
            pkg_dir.join("Cargo.lock"),
            r#"# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "test-crate"
version = "1.0.0"
"#,
        )
        .unwrap();

        let package = create_test_package(
            "test-crate",
            pkg_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![package]);

        assert!(result.is_ok());

        // Verify Cargo.toml was updated
        let toml_content =
            fs::read_to_string(pkg_dir.join("Cargo.toml")).unwrap();
        assert!(toml_content.contains(r#"version = "2.0.0""#));

        // Verify Cargo.lock was updated
        let lock_content =
            fs::read_to_string(pkg_dir.join("Cargo.lock")).unwrap();
        assert!(lock_content.contains(r#"version = "2.0.0""#));
    }

    #[test]
    fn test_update_multiple_rust_packages_with_dependencies() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        // Create two packages where one depends on the other
        let pkg1_dir = root_path.join("crate1");
        let pkg2_dir = root_path.join("crate2");
        fs::create_dir_all(&pkg1_dir).unwrap();
        fs::create_dir_all(&pkg2_dir).unwrap();

        // Package 1 depends on package 2
        fs::write(
            pkg1_dir.join("Cargo.toml"),
            r#"[package]
name = "crate1"
version = "1.0.0"

[dependencies]
crate2 = "1.0.0"
"#,
        )
        .unwrap();

        fs::write(
            pkg1_dir.join("Cargo.lock"),
            r#"# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "crate1"
version = "1.0.0"

[[package]]
name = "crate2"
version = "1.0.0"
"#,
        )
        .unwrap();

        // Package 2 is standalone
        fs::write(
            pkg2_dir.join("Cargo.toml"),
            r#"[package]
name = "crate2"
version = "1.0.0"
"#,
        )
        .unwrap();

        fs::write(
            pkg2_dir.join("Cargo.lock"),
            r#"# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "crate2"
version = "1.0.0"
"#,
        )
        .unwrap();

        let package1 = create_test_package(
            "crate1",
            pkg1_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );
        let package2 = create_test_package(
            "crate2",
            pkg2_dir.to_str().unwrap(),
            "3.0.0",
            Framework::Rust,
        );

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![package1, package2]);

        assert!(result.is_ok());

        // Verify package 1 was updated with new version and dependency
        let pkg1_toml =
            fs::read_to_string(pkg1_dir.join("Cargo.toml")).unwrap();
        assert!(pkg1_toml.contains(r#"version = "2.0.0""#));
        assert!(pkg1_toml.contains(r#"crate2 = "3.0.0""#));

        // Verify package 2 was updated
        let pkg2_toml =
            fs::read_to_string(pkg2_dir.join("Cargo.toml")).unwrap();
        assert!(pkg2_toml.contains(r#"version = "3.0.0""#));

        // Verify lockfiles were updated
        let pkg1_lock =
            fs::read_to_string(pkg1_dir.join("Cargo.lock")).unwrap();
        assert!(pkg1_lock.contains(r#"version = "2.0.0""#));
        assert!(pkg1_lock.contains(r#"version = "3.0.0""#));
    }

    #[test]
    fn test_update_workspace_scenario() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        // Create workspace structure
        let member1_dir = root_path.join("member1");
        let member2_dir = root_path.join("member2");
        fs::create_dir_all(&member1_dir).unwrap();
        fs::create_dir_all(&member2_dir).unwrap();

        // Create workspace Cargo.toml
        fs::write(
            root_path.join("Cargo.toml"),
            r#"[workspace]
members = [
    "member1",
    "member2"
]

[workspace.dependencies]
serde = "1.0"
"#,
        )
        .unwrap();

        // Create workspace Cargo.lock
        fs::write(
            root_path.join("Cargo.lock"),
            r#"# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "member1"
version = "1.0.0"

[[package]]
name = "member2"
version = "2.0.0"
"#,
        )
        .unwrap();

        // Create member packages
        fs::write(
            member1_dir.join("Cargo.toml"),
            r#"[package]
name = "member1"
version = "1.0.0"

[dependencies]
member2 = "2.0.0"
"#,
        )
        .unwrap();

        fs::write(
            member2_dir.join("Cargo.toml"),
            r#"[package]
name = "member2"
version = "2.0.0"
"#,
        )
        .unwrap();

        let package1 = create_test_package(
            "member1",
            member1_dir.to_str().unwrap(),
            "1.5.0",
            Framework::Rust,
        );
        let package2 = create_test_package(
            "member2",
            member2_dir.to_str().unwrap(),
            "2.5.0",
            Framework::Rust,
        );

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![package1, package2]);

        assert!(result.is_ok());

        // Verify workspace lockfile was updated
        let workspace_lock =
            fs::read_to_string(root_path.join("Cargo.lock")).unwrap();
        assert!(workspace_lock.contains(r#"version = "1.5.0""#));
        assert!(workspace_lock.contains(r#"version = "2.5.0""#));

        // Verify member packages were updated
        let member1_toml =
            fs::read_to_string(member1_dir.join("Cargo.toml")).unwrap();
        assert!(member1_toml.contains(r#"version = "1.5.0""#));
        assert!(member1_toml.contains(r#"member2 = "2.5.0""#));
    }

    #[test]
    fn test_update_filters_non_rust_packages() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let rust_dir = root_path.join("rust-crate");
        let node_dir = root_path.join("node-package");
        fs::create_dir_all(&rust_dir).unwrap();
        fs::create_dir_all(&node_dir).unwrap();

        // Create Rust package
        fs::write(
            rust_dir.join("Cargo.toml"),
            r#"[package]
name = "rust-crate"
version = "1.0.0"
"#,
        )
        .unwrap();

        // Create Node package (should be ignored)
        fs::write(
            node_dir.join("package.json"),
            r#"{"name": "node-package", "version": "1.0.0"}"#,
        )
        .unwrap();

        let rust_package = create_test_package(
            "rust-crate",
            rust_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );
        let node_package = create_test_package(
            "node-package",
            node_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Node,
        );

        let updater = RustUpdater::new();
        let result =
            updater.update(root_path, vec![rust_package, node_package]);

        assert!(result.is_ok());

        // Verify only Rust package was updated
        let rust_content =
            fs::read_to_string(rust_dir.join("Cargo.toml")).unwrap();
        assert!(rust_content.contains(r#"version = "2.0.0""#));

        // Verify Node package was not touched
        let node_content =
            fs::read_to_string(node_dir.join("package.json")).unwrap();
        assert!(node_content.contains(r#""version": "1.0.0""#));
    }

    #[test]
    fn test_update_empty_packages_list() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![]);

        assert!(result.is_ok());
    }

    #[test]
    fn test_update_no_rust_packages() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let node_package = create_test_package(
            "node-package",
            "path/to/node",
            "2.0.0",
            Framework::Node,
        );
        let python_package = create_test_package(
            "python-package",
            "path/to/python",
            "2.0.0",
            Framework::Python,
        );

        let updater = RustUpdater::new();
        let result =
            updater.update(root_path, vec![node_package, python_package]);

        assert!(result.is_ok());
    }

    #[test]
    fn test_update_package_name_from_manifest() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let pkg_dir = root_path.join("package-dir");
        fs::create_dir_all(&pkg_dir).unwrap();

        // Create Cargo.toml with different name than directory
        fs::write(
            pkg_dir.join("Cargo.toml"),
            r#"[package]
name = "actual-crate-name"
version = "1.0.0"
"#,
        )
        .unwrap();

        let package = create_test_package(
            "package-dir", // This will be overridden by manifest name
            pkg_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![package]);

        assert!(result.is_ok());

        // Verify the package was updated (proves name was read from manifest)
        let content = fs::read_to_string(pkg_dir.join("Cargo.toml")).unwrap();
        assert!(content.contains(r#"version = "2.0.0""#));
        assert!(content.contains(r#"name = "actual-crate-name""#));
    }

    #[test]
    fn test_update_handles_missing_files() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let pkg_dir = root_path.join("missing-files");
        fs::create_dir_all(&pkg_dir).unwrap();
        // Don't create any files

        let package = create_test_package(
            "missing-files",
            pkg_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );

        let updater = RustUpdater::new();
        let result = updater.update(root_path, vec![package]);

        // Should return an error when Cargo.toml is missing
        assert!(result.is_err());
    }

    #[test]
    fn test_update_logs_package_count() {
        let temp_dir = TempDir::new().unwrap();
        let root_path = temp_dir.path();

        let pkg_dir = root_path.join("test-crate");
        fs::create_dir_all(&pkg_dir).unwrap();

        fs::write(
            pkg_dir.join("Cargo.toml"),
            r#"[package]
name = "test-crate"
version = "1.0.0"
"#,
        )
        .unwrap();

        let rust_package = create_test_package(
            "test-crate",
            pkg_dir.to_str().unwrap(),
            "2.0.0",
            Framework::Rust,
        );
        let node_package = create_test_package(
            "node-package",
            "path/to/node",
            "2.0.0",
            Framework::Node,
        );

        let updater = RustUpdater::new();
        let result =
            updater.update(root_path, vec![rust_package, node_package]);

        // Should succeed and only process Rust packages
        assert!(result.is_ok());

        // Verify Rust package was processed
        let content = fs::read_to_string(pkg_dir.join("Cargo.toml")).unwrap();
        assert!(content.contains(r#"version = "2.0.0""#));
    }
}
